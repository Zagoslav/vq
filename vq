#!/usr/bin/env bash
# set -x
# vim: noai:ts=4:sw=4:expandtab

bash_version="${BASH_VERSION/.*}"
sys_locale="${LANG:-C}"
XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-${HOME}/.config}"
old_ifs="$IFS"

# Speed up script by not using unicode.
export LC_ALL=C
export LANG=C

# Add /usr/xpg4/bin, /usr/sbin, and /sbin to PATH.
export PATH="/usr/xpg4/bin:/usr/sbin:/sbin:${PATH}"

# Set no case match.
shopt -s nocasematch

# Reset colors and bold.
reset="\033[0m"

# DETECT INFORMATION

get_os() {
    # $kernel_name is set in a function called cache_uname and is
    # just the output of "uname -s".
    case "$kernel_name" in
        "Linux" | "GNU"*) os="Linux" ;;
        "Darwin") os="$(sw_vers -productName)" ;;
        *"BSD" | "DragonFly" | "Bitrig") os="BSD" ;;
        "CYGWIN"* | "MSYS"*) os="Windows" ;;
        "SunOS") os="Solaris" ;;
        "Haiku") os="Haiku" ;;
        "MINIX") os="MINIX" ;;
        "AIX") os="AIX" ;;
        *)
            printf "%s\n" "Unknown OS detected: '$kernel_name', aborting..." >&2
            printf "%s\n" "Open an issue on GitHub to add support for your OS." >&2
            exit 1
        ;;
    esac
}

get_distro() {
    [[ "$distro" ]] && return

    case "$os" in
        "Linux" | "BSD" | "MINIX")
            if [[ "$(< /proc/version)" == *"Microsoft"* || "$(< /proc/sys/kernel/osrelease)" == *"Microsoft"* ]]; then
                case "$distro_shorthand" in
                    "on")   distro="$(lsb_release -sir) [Windows 10]" ;;
                    "tiny") distro="Windows 10" ;;
                    *)      distro="$(lsb_release -sd) on Windows 10" ;;
                esac
                ascii_distro="Windows 10"

            elif [[ -f "/etc/GoboLinuxVersion" ]]; then
                case "$distro_shorthand" in
                    "on" | "tiny") distro="GoboLinux" ;;
                    *) distro="GoboLinux $(< /etc/GoboLinuxVersion)"
                esac

            elif [[ -f "/etc/redstar-release" ]]; then
                case "$distro_shorthand" in
                    "on" | "tiny") distro="Red Star OS" ;;
                    *) distro="Red Star OS $(awk -F'[^0-9*]' '$0=$2' /etc/redstar-release)"
                esac

            elif type -p lsb_release >/dev/null; then
                case "$distro_shorthand" in
                    "on")   lsb_flags="-sir" ;;
                    "tiny") lsb_flags="-si" ;;
                    *)      lsb_flags="-sd" ;;
                esac
                distro="$(lsb_release $lsb_flags)"

            elif type -p guix >/dev/null; then
                distro="GuixSD"

            elif type -p crux >/dev/null; then
                distro="$(crux)"
                case "$distro_shorthand" in
                    "on")   distro="${distro//version}" ;;
                    "tiny") distro="${distro//version*}" ;;
                esac

            elif [[ -d "/system/app/" && -d "/system/priv-app" ]]; then
                distro="Android $(getprop ro.build.version.release)"

            elif [[ -f "/etc/os-release" || -f "/usr/lib/os-release" ]]; then
                # Source the os-release file
                for file in /etc/os-release /usr/lib/os-release; do
                    source "$file" 2>/dev/null && break
                done

                # Format the distro name.
                case "$distro_shorthand" in
                    "on") distro="${NAME:-${DISTRIB_ID}} ${VERSION_ID:-${DISTRIB_RELEASE}}" ;;
                    "tiny") distro="${NAME:-${DISTRIB_ID:-${TAILS_PRODUCT_NAME}}}" ;;
                    "off") distro="${PRETTY_NAME:-${DISTRIB_DESCRIPTION}} ${UBUNTU_CODENAME}" ;;
                esac

                # Workarounds for distros that go against the os-release standard.
                [[ -z "${distro// }" ]] && distro="$(awk '/BLAG/ {print $1; exit}' /etc/os-release /usr/lib/os-release)"
                [[ -z "${distro// }" ]] && distro="$(awk -F'=' '{print $2; exit}' /etc/os-release /usr/lib/os-release)"

            else
                for release_file in /etc/*-release; do
                    distro+="$(< "$release_file")"
                done

                if [[ -z "$distro" ]]; then
                    case "$distro_shorthand" in
                        "on" | "tiny") distro="$kernel_name" ;;
                        *) distro="$kernel_name $kernel_version" ;;
                    esac
                    distro="${distro/DragonFly/DragonFlyBSD}"

                    # Workarounds for FreeBSD based distros.
                    [[ -f "/etc/pcbsd-lang" ]] && distro="PCBSD"
                    [[ -f "/etc/rc.conf.trueos" ]] && distro="TrueOS"
                    [[ -f "/etc/pacbsd-release" ]] && distro="PacBSD" # /etc/pacbsd-release is an empty file
                fi
            fi
            distro="$(trim_quotes "$distro")"
        ;;

        "Mac OS X")
            osx_version="$(sw_vers -productVersion)"
            osx_build="$(sw_vers -buildVersion)"

            case "$osx_version" in
                "10.4"*)  codename="Mac OS X Tiger" ;;
                "10.5"*)  codename="Mac OS X Leopard" ;;
                "10.6"*)  codename="Mac OS X Snow Leopard" ;;
                "10.7"*)  codename="Mac OS X Lion" ;;
                "10.8"*)  codename="OS X Mountain Lion" ;;
                "10.9"*)  codename="OS X Mavericks" ;;
                "10.10"*) codename="OS X Yosemite" ;;
                "10.11"*) codename="OS X El Capitan" ;;
                "10.12"*) codename="macOS Sierra" ;;
                *)        codename="macOS" ;;
            esac
            distro="$codename $osx_version $osx_build"

            case "$distro_shorthand" in
                "on") distro="${distro/ ${osx_build}}" ;;
                "tiny")
                    case "$osx_version" in
                        "10."[4-7]*) distro="${distro/${codename}/Mac OS X}" ;;
                        "10."[8-9]* | "10.1"[0-1]*) distro="${distro/${codename}/OS X}" ;;
                        "10.12"*) distro="${distro/${codename}/macOS}" ;;
                    esac
                    distro="${distro/ ${osx_build}}"
                ;;
            esac
        ;;

        "iPhone OS")
            distro="iOS $(sw_vers -productVersion)"

            # "uname -m" doesn't print architecture on iOS so we force it off.
            os_arch="off"
        ;;

        "Windows")
            distro="$(wmic os get Caption)"

            # Strip crap from the output of wmic.
            distro="${distro/Caption}"
            distro="${distro/Microsoft }"
        ;;

        "Solaris")
            case "$distro_shorthand" in
                "on" | "tiny") distro="$(awk 'NR==1{print $1 " " $3;}' /etc/release)" ;;
                *) distro="$(awk 'NR==1{print $1 " " $2 " " $3;}' /etc/release)" ;;
            esac
            distro="${distro/\(*}"
        ;;

        "Haiku")
            distro="$(uname -sv | awk '{print $1 " " $2}')"
        ;;

        "AIX")
            distro="AIX $(oslevel)"
        ;;
    esac

    [[ -z "$distro" ]] && distro="$os (Unknown)"

    # Get OS architecture.
    [[ "$os_arch" == "on" ]] && \
        distro+=" ${machine_arch}"

    [[ "${ascii_distro:-auto}" == "auto" ]] && \
        ascii_distro="$(trim "$distro")"
}

get_model() {
    case "$os" in
        "Linux")
            if [[ -d "/system/app/" && -d "/system/priv-app" ]]; then
                model="$(getprop ro.product.brand) $(getprop ro.product.model)"

            elif [[ -f /sys/devices/virtual/dmi/id/product_name ||
                    -f /sys/devices/virtual/dmi/id/product_version ]]; then
                model="$(< /sys/devices/virtual/dmi/id/product_name)"
                model+=" $(< /sys/devices/virtual/dmi/id/product_version)"

            elif [[ -f /sys/firmware/devicetree/base/model ]]; then
                model="$(< /sys/firmware/devicetree/base/model)"

            elif [[ -f /tmp/sysinfo/model ]]; then
                model="$(< /tmp/sysinfo/model)"
            fi
        ;;

        "Mac OS X") model="$(sysctl -n hw.model)" ;;
        "iPhone OS")
            case "$machine_arch" in
                "iPad1,1") model="iPad" ;;
                "iPad2,"[1-4]) model="iPad2" ;;
                "iPad3,"[1-3]) model="iPad3" ;;
                "iPad3,"[4-6]) model="iPad4" ;;
                "iPad4,"[1-3]) model="iPad Air" ;;
                "iPad5,"[3-4]) model="iPad Air 2" ;;
                "iPad6,"[7-8]) model="iPad Pro (12.9 Inch)" ;;
                "iPad6,"[3-4]) model="iPad Pro (9.7 Inch)" ;;
                "iPad2,"[5-7]) model="iPad mini" ;;
                "iPad4,"[4-6]) model="iPad mini 2" ;;
                "iPad4,"[7-9]) model="iPad mini 3" ;;
                "iPad5,"[1-2]) model="iPad mini 4" ;;

                "iPhone1,1") model="iPhone" ;;
                "iPhone1,2") model="iPhone 3G" ;;
                "iPhone2,1") model="iPhone 3GS" ;;
                "iPhone3,"[1-3]) model="iPhone 4" ;;
                "iPhone4,1") model="iPhone 4S" ;;
                "iPhone5,"[1-2]) model="iPhone 4" ;;
                "iPhone5,"[3-4]) model="iPhone 5c" ;;
                "iPhone6,"[1-2]) model="iPhone 5s" ;;
                "iPhone7,2") model="iPhone 6" ;;
                "iPhone7,1") model="iPhone 6 Plus" ;;
                "iPhone8,1") model="iPhone 6s" ;;
                "iPhone8,2") model="iPhone 6s Plus" ;;
                "iPhone8,4") model="iPhone SE" ;;
                "iPhone9,1" | "iPhone9,3") model="iPhone 7" ;;
                "iPhone9,2" | "iPhone9,4") model="iPhone 7 Plus" ;;

                "iPod1,1") model="iPod touch" ;;
                "ipod2,1") model="iPod touch 2G" ;;
                "ipod3,1") model="iPod touch 3G" ;;
                "ipod4,1") model="iPod touch 4G" ;;
                "ipod5,1") model="iPod touch 5G" ;;
                "ipod7,1") model="iPod touch 6G" ;;
            esac
        ;;

        "BSD" | "MINIX")
            model="$(sysctl -n hw.vendor hw.product)"
        ;;

        "Windows")
            model="$(wmic computersystem get manufacturer,model)"
            model="${model/Manufacturer}"
            model="${model/Model}"
        ;;

        "Solaris")
            model="$(prtconf -b | awk -F':' '/banner-name/ {printf $2}')"
        ;;

        "AIX")
            model="$(prtconf | awk -F':' '/System Model/ {printf $2}')"
        ;;
    esac

    # Remove dummy OEM info.
    model="${model//To be filled by O.E.M.}"
    model="${model//To Be Filled*}"
    model="${model//OEM*}"
    model="${model//Not Applicable}"
    model="${model//System Product Name}"
    model="${model//System Version}"
    model="${model//Undefined}"
    model="${model//Default string}"
    model="${model//Not Specified}"
    model="${model//Type1ProductConfigId}"
}

get_title() {
    user="${USER:-$(whoami || printf "%s" "${HOME/*\/}")}"
    hostname="${HOSTNAME:-$(hostname)}"
    title="${title_color}${bold}${user}${at_color}@${title_color}${bold}${hostname}"
    length="$((${#user} + ${#hostname} + 1))"
}

get_kernel() {
    # Since AIX is an integrated system, it's better to skip this function altogether
    [[ "$os" == "AIX" ]] && return

    case "$kernel_shorthand" in
        "on")  kernel="$kernel_version" ;;
        "off") kernel="$kernel_name $kernel_version" ;;
    esac

    # Hide kernel info if it's identical to the distro info.
    if [[ "$os" =~ (BSD|MINIX) && "$distro" == *"$kernel_name"* ]]; then
        case "$distro_shorthand" in
            "on" | "tiny") kernel="$kernel_version" ;;
            *) unset kernel ;;
        esac
    fi
}

get_uptime() {
    # Since Haiku's uptime cannot be fetched in seconds, a case outside
    # the usual case is needed.
    case "$os" in
        "Haiku")
            uptime="$(uptime -u)"
            uptime="${uptime/up }"
        ;;

        *)
            # Get uptime in seconds.
            case "$os" in
                "Linux" | "Windows" | "MINIX")
                    seconds="$(< /proc/uptime)"
                    seconds="${seconds/.*}"
                ;;

                "Mac OS X" | "iPhone OS" | "BSD")
                    boot="$(sysctl -n kern.boottime)"
                    boot="${boot/'{ sec = '}"
                    boot="${boot/,*}"

                    # Get current date in seconds.
                    now="$(date +%s)"
                    seconds="$((now - boot))"
                ;;

                "Solaris")
                    seconds="$(kstat -p unix:0:system_misc:snaptime | awk '{print $2}')"
                    seconds="${seconds/.*}"
                ;;

                "AIX")
                    t="$(LC_ALL=POSIX ps -o etime= -p 1)"
                    d="0" h="0"
                    case "$t" in *"-"*) d="${t%%-*}"; t="${t#*-}";; esac
                    case "$t" in *":"*":"*) h="${t%%:*}"; t="${t#*:}";; esac
                    seconds="$((d*86400 + h*3600 + ${t%%:*}*60 + ${t#*:}))"
                ;;
            esac

            days="$((seconds / 60 / 60 / 24)) days"
            hours="$((seconds / 60 / 60 % 24)) hours"
            mins="$((seconds / 60 % 60)) minutes"

            # Format the days, hours and minutes.
            strip_date() {
                case "$1" in
                    "0 "*) unset "${1/* }" ;;
                    "1 "*) printf "%s" "${1/s}" ;;
                    *)     printf "%s" "$1" ;;
                esac
            }

            days="$(strip_date "$days")"
            hours="$(strip_date "$hours")"
            mins="$(strip_date "$mins")"

            uptime="${days:+$days, }${hours:+$hours, }${mins}"
            uptime="${uptime%', '}"
            uptime="${uptime:-${seconds} seconds}"
        ;;
    esac

    # Make the output of uptime smaller.
    case "$uptime_shorthand" in
        "on")
            uptime="${uptime/minutes/mins}"
            uptime="${uptime/minute/min}"
            uptime="${uptime/seconds/secs}"
        ;;

        "tiny")
            uptime="${uptime/ days/d}"
            uptime="${uptime/ day/d}"
            uptime="${uptime/ hours/h}"
            uptime="${uptime/ hour/h}"
            uptime="${uptime/ minutes/m}"
            uptime="${uptime/ minute/m}"
            uptime="${uptime/ seconds/s}"
            uptime="${uptime//,}"
        ;;
    esac
}

get_cpu() {
    # NetBSD emulates the Linux /proc filesystem instead of using sysctl for hw
    # information so we have to use this block below which temporarily sets the
    # OS to "Linux" for the duration of this function.
    [[ "$distro" == "NetBSD"* ]] && local os="Linux"

    case "$os" in
        "Linux" | "MINIX" | "Windows")
            # Get CPU name.
            case "$distro" in
                "Android"*) cpu="$(getprop ro.product.board)" ;;
                *)
                    case "$machine_arch" in
                        "frv" | "hppa" | "m68k" | "openrisc" | "or"* | "powerpc" | "ppc"* | "sparc"*)
                            cpu="$(awk -F':' '/^cpu\t|^CPU/ {printf $2; exit}' /proc/cpuinfo)"
                        ;;
                        "s390"*)
                            cpu="$(awk -F'=' '/machine/ {print $4; exit}' /proc/cpuinfo)"
                        ;;
                        "ia64" | "m32r")
                            cpu="$(awk -F':' '/model/ {print $2; exit}' /proc/cpuinfo)"
                            [[ -z "$cpu" ]] && cpu="$(awk -F':' '/family/ {printf $2; exit}' /proc/cpuinfo)"
                        ;;
                        *)
                            cpu="$(awk -F ': | @' '/model name|Processor|^cpu model|chip type|^cpu type/ {printf $2; exit}' /proc/cpuinfo)"
                        ;;
                    esac
                ;;
            esac

            speed_dir="/sys/devices/system/cpu/cpu0/cpufreq"
            temp_dir="/sys/class/hwmon/hwmon0/temp1_input"

            # Get CPU speed.
            if [[ -d "$speed_dir" ]]; then
                # Fallback to bios_limit if $speed_type fails.
                speed="$(< "${speed_dir}/${speed_type}")" || \
                speed="$(< "${speed_dir}/bios_limit")" || \
                speed="$(< "${speed_dir}/scaling_max_freq")" || \
                speed="$(< "${speed_dir}/cpuinfo_max_freq")"
                speed="$((speed / 100000))"

            else
                speed="$(awk -F ': |\\.' '/cpu MHz/ {printf $2; exit}' /proc/cpuinfo)"
                speed="$((speed / 100))"
            fi

            # Get CPU temp.
            if [[ "$cpu_temp" != "off" && -f "$temp_dir" ]]; then
                temp="$(< "$temp_dir")"
                temp="$((temp * 100 / 10000))"

                # Convert to fahrenheit if enabled.
                [[ "$cpu_temp" == "F" ]] && temp="$((temp * 90 / 50 + 320))"

                # Format the output.
                temp="[${temp/${temp: -1}}.${temp: -1}°${cpu_temp:-C}]"
            fi

            # Get CPU cores.
            case "$cpu_cores" in
                "logical" | "on") cores="$(grep -c "^processor" /proc/cpuinfo)" ;;
                "physical") cores="$(grep "^core id" /proc/cpuinfo | sort -u | wc -l)" ;;
            esac
        ;;

        "Mac OS X")
            cpu="$(sysctl -n machdep.cpu.brand_string)"

            # Get CPU cores.
            case "$cpu_cores" in
                "logical" | "on") cores="$(sysctl -n hw.logicalcpu_max)" ;;
                "physical") cores="$(sysctl -n hw.physicalcpu_max)" ;;
            esac
        ;;

        "iPhone OS")
            case "$machine_arch" in
                "iPhone1,"[1-2] | "iPod1,1") cpu="Samsung S5L8900 (1) @ 412MHz" ;;
                "iPhone2,1") cpu="Samsung S5PC100 (1) @ 600MHz" ;;
                "iPhone3,"[1-3] | "iPod4,1") cpu="Apple A4 (1) @ 800MHz" ;;
                "iPhone4,1" | "iPod5,1") cpu="Apple A5 (2) @ 800MHz" ;;
                "iPhone5,"[1-4]) cpu="Apple A6 (2) @ 1.3GHz" ;;
                "iPhone6,"[1-2]) cpu="Apple A7 (2) @ 1.3GHz" ;;
                "iPhone7,"[1-2]) cpu="Apple A8 (2) @ 1.4GHz" ;;
                "iPhone8,"[1-4]) cpu="Apple A9 (2) @ 1.85GHz" ;;
                "iPhone9,"[1-4]) cpu="Apple A10 Fusion (4) @ 2.34GHz" ;;
                "iPod2,1") cpu="Samsung S5L8720 (1) @ 533MHz" ;;
                "iPod3,1") cpu="Samsung S5L8922 (1) @ 600MHz" ;;
                "iPod7,1") cpu="Apple A8 (2) @ 1.1GHz" ;;
                "iPad1,1") cpu="Apple A4 (1) @ 1GHz" ;;
                "iPad2,"[1-7]) cpu="Apple A5 (2) @ 1GHz" ;;
                "iPad3,"[1-3]) cpu="Apple A5X (2) @ 1GHz" ;;
                "iPad3,"[4-6]) cpu="Apple A6X (2) @ 1.4GHz" ;;
                "iPad4,"[1-3]) cpu="Apple A7 (2) @ 1.4GHz" ;;
                "iPad4,"[4-9]) cpu="Apple A7 (2) @ 1.4GHz" ;;
                "iPad5,"[1-2]) cpu="Apple A8 (2) @ 1.5GHz" ;;
                "iPad5,"[3-4]) cpu="Apple A8X (3) @ 1.5GHz" ;;
                "iPad6,"[3-4]) cpu="Apple A9X (2) @ 2.16GHz" ;;
                "iPad6,"[7-8]) cpu="Apple A9X (2) @ 2.26GHz" ;;
            esac
        ;;

        "BSD")
            # Get CPU name.
            cpu="$(sysctl -n hw.model)"
            cpu="${cpu/[0-9]\.*}"
            cpu="${cpu/ @*}"

            # Get CPU speed.
            speed="$(sysctl -n hw.cpuspeed)"
            [[ -z "$speed" ]] && speed="$(sysctl -n  hw.clockrate)"
            speed="$((speed / 100))"

            # Get CPU cores.
            cores="$(sysctl -n hw.ncpu)"

            # Get CPU temp.
            if [[ "$cpu_temp" != "off" ]]; then
                case "$kernel_name" in
                    "FreeBSD"* | "DragonFly"*)
                        temp="$(sysctl -n dev.cpu.0.temperature)"
                        temp="${temp/C}"
                    ;;
                    "OpenBSD"* | "Bitrig"*)
                        temp="$(sysctl -n hw.sensors.lm0.temp0)"
                        temp="${temp/ degC}"
                    ;;
                esac

                # Convert to fahrenheit if enabled.
                if [[ "$cpu_temp" == "F" ]]; then
                    temp="${temp//.}"
                    temp="$((temp * 90 / 50 + 320))"
                    temp="[${temp/${temp: -1}}.${temp: -1}°F]"
                else
                    temp="[${temp}°C]"
                fi

            fi
        ;;

        "Solaris")
            # Get CPU name.
            cpu="$(psrinfo -pv)"
            cpu="${cpu//*$'\n'}"
            cpu="${cpu/[0-9]\.*}"
            cpu="${cpu/ @*}"

            # Get CPU speed.
            speed="$(psrinfo -v | awk '/operates at/ {print $6; exit}')"
            speed="$((speed / 100))"

            # Get CPU cores.
            case "$cpu_cores" in
                "logical" | "on") cores="$(kstat -m cpu_info | grep -c -F "chip_id")" ;;
                "physical") cores="$(psrinfo -p)" ;;
            esac
        ;;

        "Haiku")
            # Get CPU name.
            cpu="$(sysinfo -cpu | awk -F '\\"' '/CPU #0/ {print $2}')"
            cpu="${cpu/@*}"

            # Get CPU speed.
            speed="$(sysinfo -cpu | awk '/running at/ {print $NF; exit}')"
            speed="${speed/MHz}"
            speed="$((speed / 100))"

            # Get CPU cores.
            cores="$(sysinfo -cpu | grep -c -F 'CPU #')"
        ;;

        "AIX")
            # Get CPU name.
            cpu="$(prtconf | awk -F':' '/Processor Type/ {printf $2}')"

            # Get CPU speed.
            speed="$(prtconf | awk -F':' '/Processor Clock Speed/ {printf $2}')"
            speed="${speed/MHz}"
            speed="$((speed / 100))"

            # Get CPU cores.
            case "$cpu_cores" in
                "logical" | "on") cores="$(lparstat -i | awk -F':' '/Online Virtual CPUs/ {printf $2}')" ;;
                "physical") cores="$(lparstat -i | awk -F':' '/Active Physical CPUs/ {printf $2}')"
            esac
        ;;
    esac

    # Fix for speeds under 1ghz.
    if [[ "$speed" ]]; then
        if [[ -z "${speed:1}" ]]; then
            speed="0.${speed}"
        else
            speed="${speed:0:1}.${speed:1}"
        fi

        cpu="$cpu @ ${speed}GHz $temp"
    fi

    # Remove un-needed patterns from cpu output.
    cpu="${cpu//(TM)}"
    cpu="${cpu//(tm)}"
    cpu="${cpu//(R)}"
    cpu="${cpu//(r)}"
    cpu="${cpu//CPU}"
    cpu="${cpu//Processor}"
    cpu="${cpu//Dual-Core}"
    cpu="${cpu//Quad-Core}"
    cpu="${cpu//Six-Core}"
    cpu="${cpu//Eight-Core}"
    cpu="${cpu//Core}"
    cpu="${cpu//with Radeon * Graphics}"
    cpu="${cpu//, altivec supported}"
    cpu="${cpu//FPU*}"

    # Trim spaces from core output
    cores="${cores//[[:space:]]}"

    # Add CPU cores to the output.
    [[ "$cpu_cores" != "off" && "$cores" ]] && \
        cpu="${cpu/@/(${cores}) @}"

    # Remove CPU speed from the output.
    [[ "$cpu_speed" == "off" ]] && \
        cpu="${cpu/@ *GHz}"

    # Make the output of CPU shorter.
    case "$cpu_shorthand" in
        "name")  cpu="${cpu/@*}" ;;
        "speed") cpu="${cpu#*@ }" ;;

        "on" | "tiny")
            cpu="${cpu/AMD }"
            cpu="${cpu/Intel }"
            cpu="${cpu/Core? Duo }"

            [[ "$cpu_shorthand" == "tiny" ]] && cpu="${cpu/@*}"
        ;;
    esac
}

get_cpu_usage() {
    case "$os" in
        "Windows")
            cpu_usage="$(wmic cpu get loadpercentage)"
            cpu_usage="${cpu_usage/LoadPercentage}"
            cpu_usage="${cpu_usage//[[:space:]]}"
        ;;

        *)
            # Get CPU cores if unset.
            if [[ "$cpu_cores" != "logical" ]]; then
                case "$os" in
                    "Linux" | "MINIX") cores="$(grep -c "^processor" /proc/cpuinfo)" ;;
                    "Mac OS X") cores="$(sysctl -n hw.logicalcpu_max)" ;;
                    "BSD") cores="$(sysctl -n hw.ncpu)" ;;
                    "Solaris") cores="$(kstat -m cpu_info | grep -c -F "chip_id")" ;;
                    "Haiku") cores="$(sysinfo -cpu | grep -c -F 'CPU #')" ;;
                    "iPhone OS") cores="${cpu/*\(}"; cores="${cores/\)*}" ;;
                    "AIX") cores="$(lparstat -i | awk -F':' '/Online Virtual CPUs/ {printf $2}')" ;;
                esac
            fi

            cpu_usage="$(ps aux | awk 'BEGIN {sum=0} {sum+=$3}; END {print sum}')"
            cpu_usage="$((${cpu_usage/\.*} / ${cores:-1}))"
        ;;
    esac

    # Print the bar.
    case "$cpu_display" in
        "bar") cpu_usage="$(bar "$cpu_usage" 100)" ;;
        "infobar") cpu_usage="${cpu_usage}% $(bar "$cpu_usage" 100)" ;;
        "barinfo") cpu_usage="$(bar "$cpu_usage" 100) ${cpu_usage}%" ;;
        *) cpu_usage="${cpu_usage}%" ;;
    esac
}

get_gpu() {
    case "$os" in
        "Linux")
            # Read GPUs into array.
            IFS=$'\n'
            gpus=($(lspci -mm | awk -F '\\"|\\" \\"' '/"Display|"3D|"VGA/ {print $3 " " $4}'))
            IFS="$old_ifs"

            # Number the GPUs if more than one exists.
            ((${#gpus[@]} > 1)) && gpu_num=1

            for gpu in "${gpus[@]}"; do
                # GPU shorthand tests.
                [[ "$gpu_type" == "dedicated" && "$gpu" =~ (i|I)ntel ]] || \
                [[ "$gpu_type" == "integrated" && ! "$gpu" =~ (i|I)ntel ]] && \
                    { unset -v gpu; continue; }

                case "$gpu" in
                    *"advanced"*)
                        gpu="${gpu/'[AMD/ATI]' }"
                        gpu="${gpu/'[AMD]' }"
                        gpu="${gpu/OEM }"
                        gpu="${gpu/Advanced Micro Devices, Inc.}"
                        gpu="${gpu/ \/ *}"
                        gpu="${gpu/*\[}"
                        gpu="${gpu/\]*}"
                        gpu="AMD $gpu"
                    ;;

                    *"nvidia"*)
                        gpu="${gpu/*\[}"
                        gpu="${gpu/\]*}"
                        gpu="NVIDIA $gpu"
                    ;;

                    *"intel"*)
                        gpu="Intel Integrated Graphics"
                    ;;

                    *"virtualbox"*)
                        gpu="VirtualBox Graphics Adapter"
                    ;;
                esac

                if [[ "$gpu_brand" == "off" ]]; then
                    gpu="${gpu/AMD }"
                    gpu="${gpu/NVIDIA }"
                    gpu="${gpu/Intel }"
                fi

                prin "${subtitle}${gpu_num}" "$gpu"
                ((++gpu_num))
            done

            return
        ;;

        "Mac OS X")
            if [[ -f "${cache_dir}/vq/gpu" ]]; then
                source "${cache_dir}/vq/gpu"

            else
                gpu="$(system_profiler SPDisplaysDataType | awk -F': ' '/^\ *Chipset Model:/ {printf $2 ", "}')"
                gpu="${gpu//'/ $'}"
                gpu="${gpu%,*}"

                cache "gpu" "$gpu"
            fi
        ;;

        "iPhone OS")
            case "$machine_arch" in
                "iPhone1,"[1-2]) gpu="PowerVR MBX Lite 3D" ;;
                "iPhone5,"[1-4]) gpu="PowerVR SGX543MP3" ;;
                "iPhone8,"[1-4]) gpu="PowerVR GT7600" ;;
                "iPad3,"[1-3]) gpu="PowerVR SGX534MP4" ;;
                "iPad3,"[4-6]) gpu="PowerVR SGX554MP4" ;;
                "iPad5,"[3-4]) gpu="PowerVR GXA6850" ;;
                "iPad6,"[3-8]) gpu="PowerVR 7XT" ;;

                "iPhone2,1" | "iPhone3,"[1-3] | "iPod3,1" | "iPod4,1" | "iPad1,1")
                    gpu="PowerVR SGX535"
                ;;

                "iPhone4,1" | "iPad2,"[1-7] | "iPod5,1")
                    gpu="PowerVR SGX543MP2"
                ;;

                "iPhone6,"[1-2] | "iPad4,"[1-9])
                    gpu="PowerVR G6430"
                ;;

                "iPhone7,"[1-2] | "iPod7,1" | "iPad5,"[1-2])
                    gpu="PowerVR GX6450"
                ;;

                "iPod1,1" | "iPod2,1")
                    gpu="PowerVR MBX Lite"
                ;;
            esac
        ;;

        "BSD" | "Solaris" | "MINIX" | "AIX")
            case "$kernel_name" in
                "FreeBSD"* | "DragonFly"*)
                    gpu="$(pciconf -lv | grep -B 4 -F "VGA" | grep -F "device")"
                    gpu="${gpu/*device*= }"
                    gpu="$(trim_quotes "$gpu")"
                ;;

                *)
                    gpu="$(glxinfo | grep -F 'OpenGL renderer string')"
                    gpu="${gpu/'OpenGL renderer string: '}"
                ;;
            esac
        ;;

        "Windows")
            gpu="$(wmic path Win32_VideoController get caption)"
            gpu="${gpu//Caption}"
        ;;

        "Haiku")
            gpu="$(listdev | grep -A2 -F 'device Display controller' | awk -F':' '/device beef/ {print $2}')"
        ;;
    esac

    if [[ "$gpu_brand" == "off" ]]; then
        gpu="${gpu/AMD}"
        gpu="${gpu/NVIDIA}"
        gpu="${gpu/Intel}"
    fi
}

get_memory() {
    case "$os" in
        "Linux" | "Windows")
            # MemUsed = Memtotal + Shmem - MemFree - Buffers - Cached - SReclaimable
            # Source: https://github.com/KittyKatt/screenFetch/issues/386#issuecomment-249312716
            while IFS=":" read -r a b; do
                case "$a" in
                    "MemTotal") mem_used="$((mem_used+=${b/kB}))"; mem_total="${b/kB}" ;;
                    "Shmem") mem_used="$((mem_used+=${b/kB}))"  ;;
                    "MemFree" | "Buffers" | "Cached" | "SReclaimable") mem_used="$((mem_used-=${b/kB}))" ;;
                esac
            done < /proc/meminfo

            mem_used="$((mem_used / 1024))"
            mem_total="$((mem_total / 1024))"
        ;;

        "Mac OS X" | "iPhone OS")
            mem_total="$(($(sysctl -n hw.memsize) / 1024 / 1024))"
            mem_wired="$(vm_stat | awk '/wired/ { print $4 }')"
            mem_active="$(vm_stat | awk '/active / { printf $3 }')"
            mem_compressed="$(vm_stat | awk '/occupied/ { printf $5 }')"
            mem_used="$(((${mem_wired//.} + ${mem_active//.} + ${mem_compressed//.}) * 4 / 1024))"
        ;;

        "BSD" | "MINIX")
            # Mem total.
            case "$kernel_name" in
                "NetBSD"*) mem_total="$(($(sysctl -n hw.physmem64) / 1024 / 1024))" ;;
                *) mem_total="$(($(sysctl -n hw.physmem) / 1024 / 1024))" ;;
            esac

            # Mem free.
            case "$kernel_name" in
                "NetBSD"*) mem_free="$(($(awk -F ':|kB' '/MemFree:/ {printf $2}' /proc/meminfo) / 1024))" ;;
                "FreeBSD"* | "DragonFly"*)
                    mem_free="$(top -d 1 | awk -F ',' '/^Mem:/ {print $5}')"
                    mem_free="${mem_free/M Free}"
                ;;
                "MINIX")
                    mem_free="$(top -d 1 | awk -F ',' '/^Memory:/ {print $2}')"
                    mem_free="${mem_free/M Free}"
                ;;
                "OpenBSD"*) ;;
                *) mem_free="$(($(vmstat | awk 'END{printf $5}') / 1024))" ;;
            esac

            # Mem used.
            case "$kernel_name" in
                "OpenBSD"*) mem_used="$(($(vmstat | awk 'END{printf $4}') / 1024))" ;;
                *) mem_used="$((mem_total - mem_free))" ;;
            esac
        ;;

        "Solaris")
            mem_total="$(prtconf | awk '/Memory/ {print $3}')"
            mem_free="$(($(vmstat | awk 'NR==3{printf $5}') / 1024))"
            mem_used="$((mem_total - mem_free))"
        ;;

        "Haiku")
            mem_total="$(($(sysinfo -mem | awk -F '\\/ |)' '{print $2; exit}') / 1024 / 1024))"
            mem_used="$(sysinfo -mem | awk -F '\\/|)' '{print $2; exit}')"
            mem_used="$((${mem_used/max} / 1024 / 1024))"
        ;;

        "AIX")
            mem_stat=($(svmon -G -O unit=MB))
            mem_total="${mem_stat[11]/.*}"
            mem_free="${mem_stat[16]/.*}"
            mem_used="$((mem_total - mem_free))"
        ;;
    esac
    memory="${mem_used}MB / ${mem_total}MB"

    # Bars.
    case "$memory_display" in
        "bar") memory="$(bar "${mem_used}" "${mem_total}")" ;;
        "infobar") memory="${memory} $(bar "${mem_used}" "${mem_total}")" ;;
        "barinfo") memory="$(bar "${mem_used}" "${mem_total}") ${memory}" ;;
    esac
}

get_resolution() {
    case "$os" in
        "Linux" | "BSD" | "Solaris" | "MINIX" | "AIX")
            if type -p xrandr >/dev/null; then
                case "$refresh_rate" in
                    "on") resolution="$(xrandr --nograb --current | awk 'match($0,/[0-9]*\.[0-9]*\*/) {printf $1 " @ " substr($0,RSTART,RLENGTH) "Hz, "}')" ;;
                    "off") resolution="$(xrandr --nograb --current | awk '/\*/ {printf $1 ", "}')" ;;
                esac
                resolution="${resolution//\*}"
                resolution="${resolution//\.[0-9][0-9]}"

            elif type -p xdpyinfo >/dev/null; then
                resolution="$(xdpyinfo | awk '/dimensions:/ {printf $2}')"
            fi
        ;;

        "Mac OS X")
            if type -p screenresolution >/dev/null; then
                resolution="$(screenresolution get | awk '/Display/ {printf $6 "Hz, "}')"
                resolution="${resolution//x??@/ @ }"

            else
                resolution="$(system_profiler SPDisplaysDataType | awk '/Resolution:/ {printf $2"x"$4" @ "$6"Hz, "}')"
            fi

            scale_factor="$(/usr/libexec/PlistBuddy -c "Print DisplayAnyUserSets:0:0:Resolution" /Library/Preferences/com.apple.windowserver.plist)"

            # If no refresh rate is empty.
            [[ "$resolution" == *"@ Hz"* ]] && \
                resolution="${resolution//@ Hz}"

            ((${scale_factor%.*} == 2)) && \
                resolution="${resolution// @/@2x @}"

            if [[ "$refresh_rate" == "off" ]]; then
                resolution="${resolution// @ [0-9][0-9]Hz}"
                resolution="${resolution// @ [0-9][0-9][0-9]Hz}"
            fi

            [[ "$resolution" == *"0Hz"* ]] && \
                resolution="${resolution// @ 0Hz}"
        ;;

        "Windows")
            local width=""
            width="$(wmic path Win32_VideoController get CurrentHorizontalResolution)"
            width="${width//CurrentHorizontalResolution/}"

            local height=""
            height="$(wmic path Win32_VideoController get CurrentVerticalResolution)"
            height="${height//CurrentVerticalResolution/}"

            [[ "$(trim "$width")" ]] && resolution="${width//[[:space:]]}x${height//[[:space:]]}"
        ;;

        "Haiku")
            resolution="$(screenmode | awk -F ' |, ' '{printf $2 "x" $3 " @ " $6 $7}')"

            [[ "$refresh_rate" == "off" ]] && resolution="${resolution/ @*}"
        ;;
    esac

    resolution="${resolution%,*}"
}

get_users() {
    users="$(who | awk '!seen[$1]++ {printf $1 ", "}')"
    users="${users%\,*}"
}


# TEXT FORMATTING

info() {
    # Save subtitle value.
    subtitle="$1"

    # Make sure that $prin is unset.
    unset -v prin

    # Call the function.
    "get_${2:-$1}" 2>/dev/null

    # If the get_func function called 'prin' directly, stop here.
    [[ "$prin" ]] && return

    # Update the variable.
    output="$(trim "${!2:-${!1}}")"

    if [[ "$2" && "${output// }" ]]; then
        length="$((${#1} + ${#output} + 2))"
        prin "$1" "$output"

    elif [[ "${output// }" ]]; then
        [[ -z "$length" ]] && length="${#output}"
        prin "$output"

    else
        err "Info: Couldn't detect ${1}."
    fi
}

prin() {
    # If $2 doesn't exist we format $1 as info.
    [[ -z "$2" ]] && local subtitle_color="$info_color"

    # Format the output.
    string="${1//$'\033[0m'}${2:+: $2}"
    string="$(trim "$string")"
    string="${string/:/${reset}${colon_color}:${info_color}}"
    string="${subtitle_color}${bold}${string}"

    # Print the info.
    printf "%b\n" "${text_padding:+\033[${text_padding}C}${zws}${string}${reset} "

    # Calculate info height.
    ((++info_height))

    # Log that prin was used.
    prin=1
}

get_underline() {
    if [[ "$underline_enabled" == "on" ]]; then
        printf -v underline "%${length}s"
        underline="${underline_color}${underline// /$underline_char}"
        unset -v length
    fi
}

get_line_break() {
    # Print it directly.
    printf "%s\n" "${zws} "

    # Calculate info height.
    ((++info_height))

    # Tell info() that we printed manually.
    prin=1
}

get_bold() {
    case "$ascii_bold" in
        "on") ascii_bold="\033[1m" ;;
        "off") ascii_bold="" ;;
    esac

    case "$bold" in
        "on") bold="\033[1m" ;;
        "off") bold="" ;;
    esac
}

trim() {
    # When a string is passed to "echo" all trailing and leading
    # whitespace is removed and inside the string multiple spaces are
    # condensed into single spaces.
    #
    # The "set -f/+f" is here so that "echo" doesn't cause any expansion
    # of special characters.
    #
    # The whitespace trim doesn't work with multiline strings so we use
    # "${1//[[:space:]]/ }" to remove newlines before we trim the whitespace.

    set -f
    # shellcheck disable=2086
    builtin echo -E ${1//[[:space:]]/ }
    set +f
}

trim_quotes() {
    trim_output="${1//\'}"
    trim_output="${trim_output//\"}"
    printf "%s" "$trim_output"
}

uppercase() {
    ((bash_version >= 4)) && printf "%s" "${1^}"
}

# OTHER

err() {
    err+="$(color 1)[!]\033[0m $1\n"
}

get_script_dir() {
    [[ "$script_dir" ]] && return

    # Use $0 to get the script's physical path.
    cd "${0%/*}" || exit
    script_dir="${0##*/}"

    # Iterate down a (possible) chain of symlinks.
    while [[ -L "$script_dir" ]]; do
        script_dir="$(readlink "$script_dir")"
        cd "${script_dir%/*}" || exit
        script_dir="${script_dir##*/}"
    done

    # Final directory.
    script_dir="$(pwd -P)"
}

get_default_config() {
    if [[ -f "/usr/share/vq/config" ]]; then
        default_config="/usr/share/vq/config"

    elif [[ -f "/usr/local/share/vq/config" ]]; then
        default_config="/usr/local/share/vq/config"

    elif [[ -f "/data/data/com.termux/files/usr/share/vq/config" ]]; then
        default_config="/data/data/com.termux/files/usr/share/vq/config"

    else
        get_script_dir
        default_config="${script_dir}/config/config"
        travis_config="${script_dir}/config/travis"
    fi

    if source "$default_config"; then
        err "Config: Sourced default config. (${default_config})"
    else
        err "Config: Default config not found, continuing..."
    fi
}

get_user_config() {
    # Check $config_file.
    if [[ -f "$config_file" ]]; then
        source "$config_file"
        err "Config: Sourced user config.    (${config_file})"
        old_options
        return

    elif [[ "$config_file" == "travis" ]]; then
        source "$travis_config"
        err "Config: Sourced user config.    (${travis_config})"
        old_options
        return
    fi
    mkdir -p "${XDG_CONFIG_HOME}/vq/"

    # Check ${XDG_CONFIG_HOME}/vq and create the
    # dir/files if they don't exist.
    if [[ -f "${XDG_CONFIG_HOME}/vq/config" ]]; then
        config_file="${XDG_CONFIG_HOME}/vq/config"

    elif [[ -f "/usr/share/vq/config" ]]; then
        cp "/usr/share/vq/config" "${XDG_CONFIG_HOME}/vq"
        config_file="${XDG_CONFIG_HOME}/vq/config"

    elif [[ -f "/usr/local/share/vq/config" ]]; then
        cp "/usr/local/share/vq/config" "${XDG_CONFIG_HOME}/vq"
        config_file="${XDG_CONFIG_HOME}/vq/config"

    else
        get_script_dir

        cp "${script_dir}/config/config" "${XDG_CONFIG_HOME}/vq"
        config_file="${XDG_CONFIG_HOME}/vq/config"
    fi

    source "$config_file"
    err "Config: Sourced user config.    (${config_file})"
    old_options
}

bar() {
    # Get the values.
    elapsed="$(($1 * bar_length / $2))"

    # Create the bar with spaces.
    printf -v prog  "%${elapsed}s"
    printf -v total "%$((bar_length - elapsed))s"

    # Set the colors and swap the spaces for $bar_char_.
    bar+="${bar_color_elapsed}${prog// /$bar_char_elapsed}"
    bar+="${bar_color_total}${total// /$bar_char_total}"

    # Borders.
    [[ "$bar_border" == "on" ]] && \
        bar="$(color fg)[${bar}$(color fg)]"

    printf "%b\n" "${bar}${info_color}"
}

cache() {
    if [[ "$2" ]]; then
        mkdir -p "${cache_dir}/vq"
        printf "%s" "${1/*-}=\"$2\"" > "${cache_dir}/vq/${1/*-}"
    fi
}

get_cache_dir() {
    case "$os" in
        "Mac OS X") cache_dir="/Library/Caches" ;;
        *) cache_dir="/tmp" ;;
    esac
}

kde_config_dir() {
    # If the user is using KDE get the KDE
    # configuration directory.
    if [[ "$kde_config_dir" ]]; then
        return

    elif type -p kf5-config >/dev/null 2>&1; then
        kde_config_dir="$(kf5-config --path config)"

    elif type -p kde4-config >/dev/null 2>&1; then
        kde_config_dir="$(kde4-config --path config)"

    elif type -p kde-config >/dev/null 2>&1; then
        kde_config_dir="$(kde-config --path config)"

    elif [[ -d "${HOME}/.kde4" ]]; then
        kde_config_dir="${HOME}/.kde4/share/config"

    elif [[ -d "${HOME}/.kde3" ]]; then
        kde_config_dir="${HOME}/.kde3/share/config"
    fi

    kde_config_dir="${kde_config_dir/$'/:'*}"
}

get_term_padding() {
    # Terminal info.
    #
    # Parse terminal config files to get
    # info about padding. Due to how w3m-img
    # works padding around the terminal throws
    # off the cursor placement calculation in
    # specific terminals.
    #
    # Note: This issue only seems to affect
    # URxvt.
    ((term_run != 1)) && get_term

    case "$term" in
        "URxvt"*)
            border="$(xrdb -query | awk -F ':' '/^(URxvt|\*).internalBorder/ {printf $2; exit}')"
        ;;
    esac
}

dynamic_prompt() {
    case "$image_backend" in
        "image")
            get_term_padding 2>/dev/null

            # Calculate image height in terminal cells.
            lines="$(((border * 2 + height + yoffset) / font_height))"
        ;;
        "off") return ;;
    esac

    # If the info is higher than the ascii/image place the prompt
    # based on the info height instead of the ascii/image height.
    if ((lines < info_height)); then
        printf "\n"
        return
    else
        lines="$((lines - info_height))"
    fi

    # Set the prompt location.
    if ((lines < 0)); then
        printf "%b" "\033[${lines/-}A"
    else
        printf "%b" "\033[${lines}B"
    fi

    # Add some padding.
    printf "\n\n\n\n"
}

cache_uname() {
    # Cache the output of uname so we don't
    # have to spawn it multiple times.
    uname=($(uname -srm))

    kernel_name="${uname[0]}"
    kernel_version="${uname[1]}"
    machine_arch="${uname[2]}"
}

convert_time() {
    # Convert ls timestamp to 'Tue 06 Dec 2016 4:58 PM' format.
    year="$1"
    day="$3"

    # Split time into hours/minutes.
    hour="${4/:*}"
    min="${4/${hour}}"

    # Get month. (Month code is used for day of week)
    # Due to different versions of 'ls', the month can be 1, 01 or Jan.
    case "$2" in
        1  | 01 | "Jan") month="Jan"; month_code=0 ;;
        2  | 02 | "Feb") month="Feb"; month_code=3 ;;
        3  | 03 | "Mar") month="Mar"; month_code=3 ;;
        4  | 04 | "Apr") month="Apr"; month_code=6 ;;
        5  | 05 | "May") month="May"; month_code=1 ;;
        6  | 06 | "Jun") month="Jun"; month_code=4 ;;
        7  | 07 | "Jul") month="Jul"; month_code=6 ;;
        8  | 08 | "Aug") month="Aug"; month_code=2 ;;
        9  | 09 | "Sep") month="Sep"; month_code=5 ;;
        10      | "Oct") month="Oct"; month_code=0 ;;
        11      | "Nov") month="Nov"; month_code=3 ;;
        12      | "Dec") month="Dec"; month_code=5 ;;
    esac

    # Get leap year.
    # Source: http://stackoverflow.com/questions/725098/leap-year-calculation
    [[ "$((year % 4))" == 0 && "$((year % 100))" != 0 || "$((year % 400))" == 0 ]] && \
    [[ "$month" =~ (Jan|Feb) ]] && \
        leap_code=1

    # Calculate day of week.
    # Source: http://blog.artofmemory.com/how-to-calculate-the-day-of-the-week-4203.html
    year_code="$((${year/??} + (${year/??} / 4) % 7))"
    week_day="$(((year_code + month_code + 6 + day - leap_code) % 7))"

    case "$week_day" in
        0) week_day="Sun" ;;
        1) week_day="Mon" ;;
        2) week_day="Tue" ;;
        3) week_day="Wed" ;;
        4) week_day="Thu" ;;
        5) week_day="Fri" ;;
        6) week_day="Sat" ;;
    esac

    # Convert 24 hour time to 12 hour time + AM/PM.
    case "$install_time_format" in
        "12h")
            case "$hour" in
                [0-9] | 0[0-9] | 1[0-1]) time="${hour/00/12}${min} AM" ;;
                *) time="$((hour - 12))${min} PM" ;;
            esac
        ;;
        *) time="$4" ;;
    esac

    # Toggle showing the time.
    [[ "$install_time" == "off" ]] && unset time

    # Print the install date.
    printf "%s" "$week_day $day $month $year $time"
}

get_ppid() {
    # Get parent process ID of PID.
    case "$os" in
        "Windows")
            ppid="$(ps -p "${1:-$PPID}" | awk '{printf $2}')"
            ppid="${ppid/'PPID'}"
        ;;

        "Linux")
            ppid="$(grep -i -F "PPid:" "/proc/${1:-$PPID}/status")"
            ppid="$(trim "${ppid/PPid:}")"
        ;;

        *)
            ppid="$(ps -p "${1:-$PPID}" -o ppid=)"
        ;;
    esac

    printf "%s" "$ppid"
}

get_process_name() {
    # Get PID name.
    case "$os" in
        "Windows")
            name="$(ps -p "${1:-$PPID}" | awk '{printf $8}')"
            name="${name/'COMMAND'}"
            name="${name/*\/}"
        ;;

        "Linux")
            name="$(< "/proc/${1:-$PPID}/comm")"
        ;;

        *)
            name="$(ps -p "${1:-$PPID}" -o comm=)"
        ;;
    esac

    printf "%s" "$name"
}

decode_url() {
    decode="${1//+/ }"
    printf "%b" "${decode//%/\\x}"
}

# FINISH UP

usage() { printf "%s" "\
Usage: vq --option \"value\" --option \"value\"

vq is a CLI system information tool written in BASH. vq
displays information about your system next to an image, your OS logo,
or any ASCII file of your choice.

NOTE: Every launch flag has a config option.

Options:

INFO:
    --disable infoname          Allows you to disable an info line from appearing
                                in the output.

                                NOTE: You can supply multiple args. eg. 'vq --disable cpu gpu disk shell'

    --os_arch on/off            Hide/Show OS architecture.
    --speed_type type           Change the type of cpu speed to display.
                                Possible values: current, min, max, bios,
                                scaling_current, scaling_min, scaling_max

                                NOTE: This only supports Linux with cpufreq.

    --cpu_shorthand type        Shorten the output of CPU
                                Possible values: name, speed, tiny, on, off
    --cpu_cores type            Whether or not to display the number of CPU cores
                                Takes: logical, physical, off

                                NOTE: 'physical' doesn't work on BSD.

    --cpu_speed on/off          Hide/Show cpu speed.
    --cpu_temp C/F/off          Hide/Show cpu temperature.

                                NOTE: This only works on Linux and BSD.

                                NOTE: For FreeBSD-based systems, you need to enable coretemp kernel module.

    --distro_shorthand on/off   Shorten the output of distro (tiny, on, off)

                                NOTE: This option won't work in Windows (Cygwin)

    --kernel_shorthand on/off   Shorten the output of kernel

                                NOTE: This option won't work in BSDs (except PacBSD and PC-BSD)

    --uptime_shorthand on/off   Shorten the output of uptime (tiny, on, off)
    --refresh_rate on/off       Whether to display the refresh rate of each monitor
                                Unsupported on Windows
    --gpu_brand on/off          Enable/Disable GPU brand in output. (AMD/NVIDIA/Intel)
    --gpu_type type             Which GPU to display. (all, dedicated, integrated)

                                NOTE: This only supports Linux.

    --gtk_shorthand on/off      Shorten output of gtk theme/icons
    --gtk2 on/off               Enable/Disable gtk2 theme/font/icons output
    --gtk3 on/off               Enable/Disable gtk3 theme/font/icons output
    --shell_path on/off         Enable/Disable showing \$SHELL path
    --shell_version on/off      Enable/Disable showing \$SHELL version
    --disk_show value           Which disks to display.
                                Takes: '/', '/dev/sdXX', '/path/to/mount point'

                                NOTE: Multiple values can be given. (--disk_show '/' '/dev/sdc1')

    --disk_subtitle name/mount  What information to append to the Disk subtitle.

                                'name' shows the disk's name (sda1, sda2, etc)

                                'mount' shows the disk's mount point (/, /mnt/Local Disk, etc)

    --ip_host url               URL to query for public IP
    --song_shorthand on/off     Print the Artist/Title on separate lines
    --install_time on/off       Enable/Disable showing the time in Install Date output.
    --install_time_format 12h/24h
                                Set time format in Install Date to be 12 hour or 24 hour.

TEXT FORMATTING:
    --colors x x x x x x        Changes the text colors in this order:
                                title, @, underline, subtitle, colon, info
    --underline on/off          Enable/Disable the underline.
    --underline_char char       Character to use when underlining title
    --bold on/off               Enable/Disable bold text

COLOR BLOCKS:
    --color_blocks on/off       Enable/Disable the color blocks
    --block_width num           Width of color blocks in spaces
    --block_height num          Height of color blocks in lines
    --block_range num num       Range of colors to print as blocks

BARS:
    --bar_char 'elapsed char' 'total char'
                                Characters to use when drawing bars.
    --bar_border on/off         Whether or not to surround the bar with '[]'
    --bar_length num            Length in spaces to make the bars.
    --bar_colors num num        Colors to make the bar.
                                Set in this order: elapsed, total
    --cpu_display mode          Bar mode.
                                Takes: bar, infobar, barinfo, off
    --memory_display mode       Bar mode.
                                Takes: bar, infobar, barinfo, off
    --battery_display mode      Bar mode.
                                Takes: bar, infobar, barinfo, off
    --disk_display mode         Bar mode.
                                Takes: bar, infobar, barinfo, off
IMAGE:
    --image type                Image source. Where and what image we display.
                                Possible values: wall, ascii,
                                /path/to/img, /path/to/dir/, off
    --size 00px | --size 00%    How to size the image.
                                Possible values: auto, 00px, 00%, none
    --crop_mode mode            Which crop mode to use
                                Takes the values: normal, fit, fill
    --crop_offset value         Change the crop offset for normal mode.
                                Possible values: northwest, north, northeast,
                                west, center, east, southwest, south, southeast

    --xoffset px                How close the image will be to the left edge of the
                                window. This only works with w3m.
    --yoffset px                How close the image will be to the top edge of the
                                window. This only works with w3m.
    --bg_color color            Background color to display behind transparent image.
                                This only works with w3m.
    --gap num                   Gap between image and text.

                                NOTE: --gap can take a negative value which will move the text closer to the left side.

    --clean                     Delete cached files and thumbnails.

ASCII:
    --ascii value               Where to get the ascii from, Possible values:
                                distro, /path/to/ascii
    --ascii_colors x x x x x x  Colors to print the ascii art
    --ascii_distro distro       Which Distro's ascii art to print

                                NOTE: Arch and Ubuntu have 'old' logo variants.

                                NOTE: Use 'arch_old' or 'ubuntu_old' to use the old logos.

                                NOTE: Ubuntu has flavor variants.

                                NOTE: Change this to 'Lubuntu', 'Xubuntu', 'Ubuntu-GNOME', 'Ubuntu-Studio' or 'Ubuntu-Budgie' to use the flavors.

                                NOTE: Alpine, Arch, Crux, Gentoo, OpenBSD, and Void have a smaller logo variant.

                                NOTE: Change this to 'alpine_small', 'arch_small', 'crux_small', 'gentoo_small', 'openbsd_small', and 'void_small' to use the small logos.

    --ascii_bold on/off         Whether or not to bold the ascii logo.
    -L, --logo                  Hide the info text and only show the ascii logo.

SCREENSHOT:
    -s, --scrot /path/to/img    Take a screenshot, if path is left empty the screen-
                                shot function will use \$scrot_dir and \$scrot_name.
    -su, --upload /path/to/img  Same as --scrot but uploads the scrot to a website.
    --image_host                Website to upload scrots to. Takes: imgur, teknik
    --scrot_cmd cmd             Screenshot program to launch

OTHER:
    --config /path/to/config    Specify a path to a custom config file
    --config none               Launch the script without a config file
    --help                      Print this text and exit
    --version                   Show vq version
    -v                          Display error messages.
    -vv                         Display a verbose log for error reporting.

DEVELOPER:
    --gen-man                   Generate a manpage for vq in your PWD. (Requires GNU help2man)


Report bugs to https://github.com/dylanaraps/vq/issues

"
exit 1
}

version() { printf "%s" "\
vq 2.1.0

Copyright (c) 2016-2017 Dylan Araps

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the 'Software'), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

Written by Dylan Araps with help from the following people:

https://github.com/dylanaraps/vq/contributors

"
exit 1
}

get_args() {
    # Check the commandline flags early for '--config'.
    [[ "$@" =~ --config ]] || get_user_config 2>/dev/null

    while [[ "$1" ]]; do
        case "$1" in
            # Info
            "--os_arch") os_arch="$2" ;;
            "--cpu_cores") cpu_cores="$2" ;;
            "--cpu_speed") cpu_speed="$2" ;;
            "--speed_type") speed_type="$2" ;;
            "--distro_shorthand") distro_shorthand="$2" ;;
            "--kernel_shorthand") kernel_shorthand="$2" ;;
            "--uptime_shorthand") uptime_shorthand="$2" ;;
            "--cpu_shorthand") cpu_shorthand="$2" ;;
            "--gpu_brand") gpu_brand="$2" ;;
            "--gpu_type") gpu_type="$2" ;;
            "--refresh_rate") refresh_rate="$2" ;;
            "--gtk_shorthand") gtk_shorthand="$2" ;;
            "--gtk2") gtk2="$2" ;;
            "--gtk3") gtk3="$2" ;;
            "--shell_path") shell_path="$2" ;;
            "--shell_version") shell_version="$2" ;;
            "--ip_host") public_ip_host="$2" ;;
            "--song_shorthand") song_shorthand="$2" ;;
            "--install_time") install_time="$2" ;;
            "--install_time_format") install_time_format="$2" ;;
            "--cpu_temp")
                cpu_temp="$2"
                [[ "$cpu_temp" == "on" ]] && cpu_temp="C"
            ;;

            "--disk_subtitle") disk_subtitle="$2" ;;
            "--disk_show")
                unset disk_show
                for arg in "$@"; do
                    case "$arg" in
                        "--disk_show") ;;
                        "-"*) break ;;
                        *) disk_show+=($arg)
                    esac
                done
            ;;

            "--disable")
                for func in "$@"; do
                    case "$func" in
                        "--disable") continue ;;
                        "-"*) break ;;
                        *)
                            ((bash_version >= 4)) && func="${func,,}"
                            unset -f "get_$func"
                        ;;
                    esac
                done
            ;;

            # Text Colors
            "--colors")
                unset colors
                for arg in "$2" "$3" "$4" "$5" "$6" "$7"; do
                    case "$arg" in
                        "-"*) break ;;
                        *) colors+=($arg)
                    esac
                done
                colors+=(7 7 7 7 7 7)
            ;;

            # Text Formatting
            "--underline") underline_enabled="$2" ;;
            "--underline_char") underline_char="$2" ;;
            "--bold") bold="$2" ;;

            # Color Blocks
            "--color_blocks") color_blocks="$2" ;;
            "--block_range") block_range=("$2" "$3") ;;
            "--block_width") block_width="$2" ;;
            "--block_height") block_height="$2" ;;

            # Bars
            "--bar_char")
                bar_char_elapsed="$2"
                bar_char_total="$3"
            ;;

            "--bar_border") bar_border="$2" ;;
            "--bar_length") bar_length="$2" ;;
            "--bar_colors")
                bar_color_elapsed="$2"
                bar_color_total="$3"
            ;;

            "--cpu_display") cpu_display="$2" ;;
            "--memory_display") memory_display="$2" ;;
            "--battery_display") battery_display="$2" ;;
            "--disk_display") disk_display="$2" ;;

            # Image
            "--image")
                image_source="$2"
                case "$2" in "-"* | "" | "ascii") image_backend="ascii" ;; esac
            ;;

            "--image_size" | "--size") image_size="$2" ;;
            "--crop_mode") crop_mode="$2" ;;
            "--crop_offset") crop_offset="$2" ;;
            "--xoffset") xoffset="$2" ;;
            "--yoffset") yoffset="$2" ;;
            "--background_color" | "--bg_color") background_color="$2" ;;
            "--gap") gap="$2" ;;
            "--clean")
                [[ -d "$thumbnail_dir" ]] && rm -rf "$thumbnail_dir"
                rm -rf "/Library/Caches/vq/"
                rm -rf "/tmp/vq/"
                exit
            ;;

            # Ascii
            "--ascii")
                image_backend="ascii"
                ascii="$2"
                case "$2" in "-"* | "") ascii="distro" ;; esac
            ;;

            "--ascii_colors")
                unset ascii_colors
                for arg in "$2" "$3" "$4" "$5" "$6" "$7"; do
                    case "$arg" in
                        "-"*) break ;;
                        *) ascii_colors+=($arg)
                    esac
                done
                ascii_colors+=(7 7 7 7 7 7)
            ;;

            "--ascii_distro")
                image_backend="ascii"
                ascii_distro="$2"
                case "$2" in "-"* | "") ascii_distro="$distro" ;; esac
            ;;

            "--ascii_bold") ascii_bold="$2" ;;
            "--logo" | "-L")
                image_backend="ascii"
                print_info() { info line_break; }
            ;;

            # Screenshot
            "--scrot" | "-s")
                scrot_args "$@"
            ;;
            "--upload" | "-su")
                scrot_upload="on"
                scrot_args "$@"
            ;;

            "--image_host") image_host="$2" ;;
            "--scrot_cmd") scrot_cmd="$2" ;;

            # Other
            "--config")
                case "$2" in
                    "none" | "off" | "") config="off" ;;
                    *) config_file="$2"; config="on"; get_user_config 2>/dev/null ;;
                esac
            ;;
            "-v") verbose="on" ;;
            "-vv") set -x; verbose="on" ;;
            "--help") usage ;;
            "--version") version ;;
            "--gen-man") help2man -n"A fast, highly customizable system info script" -N ./vq -o vq.1; exit 1 ;;
        esac

        shift
    done
}

main() {
    cache_uname
    get_os
    get_default_config 2>/dev/null
    get_args "$@"
    get_distro 2>/dev/null
    get_bold
    get_distro_colors

    # Minix doesn't support these sequences.
    if [[ "$TERM" != "minix" ]]; then
        # If the script exits for any reason, unhide the cursor.
        trap 'printf "\033[?25h\033[?7h"' EXIT

        # Hide the cursor and disable line wrap.
        printf "\033[?25l\033[?7l"
    fi

    get_image_backend
    old_functions
    get_cache_dir
    print_info 2>/dev/null
    dynamic_prompt

    # w3m-img: Draw the image a second time to fix
    # rendering issues in specific terminal emulators.
    [[ "$image_backend" == "image" && "$image_program" == "w3m" ]] && display_image

    # Take a screenshot.
    [[ "$scrot" == "on" ]] && take_scrot

    # Show error messages.
    [[ "$verbose" == "on" ]] && printf "%b" "$err" >&2

    return 0
}

main "$@"
